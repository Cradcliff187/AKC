<script>
if (typeof window.TimeLogger === 'undefined') {
  // Local MessageAlert component (used only within TimeLogger)
  const MessageAlert = ({ message }) => {
    if (!message.text) return null;
    
    const styles = {
      success: 'bg-green-100 text-green-700 border-green-400',
      error: 'bg-red-100 text-red-700 border-red-400',
      warning: 'bg-yellow-100 text-yellow-700 border-yellow-400'
    };

    return React.createElement('div', {
      className: `p-4 mb-4 rounded border ${styles[message.type] || styles.error}`
    }, message.text);
  };

  // Main TimeLogger component
  const TimeLogger = ({ projectId, onBack }) => {
    // Combine all state into one useState
    const [state, setState] = React.useState({
      loading: false,
      timeEntries: [],
      error: null,
      date: new Date().toISOString().split('T')[0],
      startTime: '',
      endTime: '',
      projects: [],
      selectedProject: '',
      forUserEmail: '',
      message: { text: '', type: '' },
      hours: 0
    });

    // Use destructuring to access state
    const { loading, timeEntries, error, date, startTime, endTime, projects, selectedProject, forUserEmail, message, hours } = state;

    // Update state using spread operator
    const setLoading = (value) => {
      setState(prev => ({ ...prev, loading: value }));
    };

    const setDate = (value) => {
      setState(prev => ({ ...prev, date: value }));
    };

    const setStartTime = (value) => {
      setState(prev => ({ ...prev, startTime: value }));
    };

    const setEndTime = (value) => {
      setState(prev => ({ ...prev, endTime: value }));
    };

    const setProjects = (value) => {
      setState(prev => ({ ...prev, projects: value }));
    };

    const setSelectedProject = (value) => {
      setState(prev => ({ ...prev, selectedProject: value }));
    };

    const setForUserEmail = (value) => {
      setState(prev => ({ ...prev, forUserEmail: value }));
    };

    const setMessage = (value) => {
      setState(prev => ({ ...prev, message: value }));
    };

    const setHours = (value) => {
      setState(prev => ({ ...prev, hours: value }));
    };

    const mountedRef = React.useRef(true);
  
    React.useEffect(() => {
      if (!window.CONSTANTS.PERMISSIONS.PROJECT.timeTracking?.submit?.includes(
        window.CONSTANTS.USER_ROLE
      )) {
        showMessage('Insufficient permissions', 'error');
        return;
      }
      
      mountedRef.current = true;
      return () => { mountedRef.current = false; };
    }, []);
  
    const validateProjectStatus = (project) => {
      const allowedStatuses = ['APPROVED', 'IN_PROGRESS'];
      return allowedStatuses.includes(project.status);
    };
  
    const filterActiveProjects = (projects) => {
      return projects.filter(project => validateProjectStatus(project));
    };
  
    const validateTimeEntry = (date, start, end) => {
      const startDate = new Date(`${date} ${start}`);
      const endDate = new Date(`${date} ${end}`);
      const diffHours = (endDate - startDate) / (1000 * 60 * 60);
      
      if (diffHours <= 0) {
        throw new Error('End time must be after start time');
      }
      
      if (diffHours > 24) {
        throw new Error('Time entry cannot exceed 24 hours');
      }
      
      return true;
    };
  
    // Fetch projects on mount
    React.useEffect(() => {
      const fetchProjects = async () => {
        if (!mountedRef.current) return;
        try {
          const response = await new Promise(resolve => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(err => resolve({ success: false, error: err.message }))
              .getProjects();
          });
          if (mountedRef.current) {
            if (response.success) {
              setProjects(filterActiveProjects(response.data));
            } else {
              showMessage(response.error || 'Failed to load projects', 'error');
            }
          }
        } catch (error) {
          if (mountedRef.current) {
            showMessage('Failed to load projects', 'error');
          }
        }
      };
      fetchProjects();
    }, []);
  
    // Calculate hours whenever date, startTime, or endTime changes
    React.useEffect(() => {
      if (startTime && endTime) {
        const start = new Date(`${date} ${startTime}`);
        const end = new Date(`${date} ${endTime}`);
        const diff = (end - start) / (1000 * 60 * 60);
        if (mountedRef.current) {
          setHours(diff > 0 ? diff : 0);
        }
      }
    }, [date, startTime, endTime]);
  
    const showMessage = (text, type) => {
      if (!mountedRef.current) return;
      setMessage({ text, type });
    };
  
    const resetForm = () => {
      if (!mountedRef.current) return;
      google.script.run
        .withSuccessHandler(newDate => {
          if (mountedRef.current) {
            setDate(newDate);
            setStartTime('');
            setEndTime('');
            setSelectedProject('');
            setForUserEmail('');
            setMessage({ text: '', type: '' });
            setHours(0);
          }
        })
        .getTodayDate();
    };
  
    const handleSubmit = async (e) => {
      e.preventDefault();
      if (!mountedRef.current) return;
  
      try {
        // Validate time entry
        validateTimeEntry(date, startTime, endTime);
        
        // Validate project status
        const project = projects.find(p => p.id === selectedProject);
        if (!validateProjectStatus(project)) {
          throw new Error('Cannot log time for inactive projects');
        }
  
        setLoading(true);
        const timeLogData = {
          date,
          startTime,
          endTime,
          projectId: selectedProject,
          forUserEmail,
          hours
        };
  
        const response = await new Promise(resolve => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(err => resolve({ success: false, error: err.message }))
            .submitTimeLog(timeLogData);
        });
  
        if (!mountedRef.current) return;
  
        if (response.success) {
          await logTimeActivity(timeLogData);
          showMessage(
            `Time logged successfully! ${response.data.hours.toFixed(2)} hours recorded.`,
            'success'
          );
          setTimeout(() => {
            if (mountedRef.current) resetForm();
          }, 2000);
        } else {
          throw new Error(response.error || 'Failed to log time');
        }
      } catch (error) {
        if (mountedRef.current) {
          showMessage(error.message || 'Failed to log time', 'error');
        }
      } finally {
        if (mountedRef.current) {
          setLoading(false);
        }
      }
    };
  
    const logTimeActivity = async (timeLogData) => {
      await google.script.run
        .withFailureHandler(error => console.error('Activity log error:', error))
        .logActivity({
          action: 'TIME_LOG_SUBMIT',
          moduleType: 'TIME_LOGS',
          referenceId: timeLogData.projectId,
          details: {
            hours: timeLogData.hours,
            date: timeLogData.date,
            forUserEmail: timeLogData.forUserEmail
          }
        });
    };
  
    const generateTimeOptions = () => {
      const options = [];
      for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 15) {
          const hourStr = hour.toString().padStart(2, '0');
          const minStr = minute.toString().padStart(2, '0');
          const time = `${hourStr}:${minStr}`;
          const label = new Date(`2000-01-01 ${time}`).toLocaleTimeString([], {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
          options.push(React.createElement('option', { key: time, value: time }, label));
        }
      }
      return options;
    };
  
    return React.createElement('div', { className: 'max-w-2xl mx-auto p-4' },
      React.createElement('div', { className: 'bg-white shadow rounded-lg p-6' },
        React.createElement('h2', { className: 'text-2xl font-bold mb-4' }, 'Log Time'),
  
        React.createElement(MessageAlert, { message }),
  
        React.createElement('form', { onSubmit: handleSubmit, className: 'space-y-4' },
          // Date
          React.createElement('div', null,
            React.createElement('label', { className: 'block text-sm font-medium mb-1' }, 'Date:'),
            React.createElement('input', {
              type: 'date',
              value: date,
              onChange: e => setDate(e.target.value),
              className: 'w-full p-2 border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500',
              required: true
            })
          ),
          // Start / End
          React.createElement('div', { className: 'grid grid-cols-2 gap-4' },
            // Start
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-sm font-medium mb-1' }, 'Start Time:'),
              React.createElement('select', {
                value: startTime,
                onChange: e => setStartTime(e.target.value),
                className: 'w-full p-2 border rounded',
                required: true
              },
                React.createElement('option', { value: '' }, 'Select Time'),
                generateTimeOptions()
              )
            ),
            // End
            React.createElement('div', null,
              React.createElement('label', { className: 'block text-sm font-medium mb-1' }, 'End Time:'),
              React.createElement('select', {
                value: endTime,
                onChange: e => setEndTime(e.target.value),
                className: 'w-full p-2 border rounded',
                required: true
              },
                React.createElement('option', { value: '' }, 'Select Time'),
                generateTimeOptions()
              )
            )
          ),
          React.createElement('div', null,
            React.createElement('label', { className: 'block text-sm font-medium mb-1' }, 'Project:'),
            React.createElement('select', {
              value: selectedProject,
              onChange: e => setSelectedProject(e.target.value),
              className: 'w-full p-2 border rounded',
              required: true
            },
              React.createElement('option', { value: '' }, 'Select Project'),
              projects.map(project =>
                React.createElement('option', {
                  key: project.id,
                  value: project.id
                }, 
                  `${project.projectId} - ${project.name}${project.jobId ? ` (Job: ${project.jobId})` : ''} - ${project.status}`
                )
              )
            )
          ),
          // ForUserEmail
          React.createElement('div', null,
            React.createElement('label', { className: 'block text-sm font-medium mb-1' }, 'For Which Employee Email (optional):'),
            React.createElement('input', {
              type: 'email',
              placeholder: 'If blank, logs for yourself',
              value: forUserEmail,
              onChange: e => setForUserEmail(e.target.value),
              className: 'w-full p-2 border rounded'
            })
          ),
          // Submit
          React.createElement('button', {
            type: 'submit',
            disabled: loading,
            className: `w-full p-3 rounded text-white font-medium ${
              loading ? 'bg-blue-400' : 'bg-blue-600 hover:bg-blue-700'
            }`
          }, loading ? 'Logging...' : hours > 0 ? `Log Time (${hours.toFixed(2)} hrs)` : 'Log Time')
        )
      )
    );
  };

  // Register with ComponentRegistry
  window.ComponentRegistry.register('TimeLogger', TimeLogger);
}
</script>